
### 1. Creational Patterns
- **What it Solves**: Focuses on object creation mechanisms, making them flexible, efficient, and reusable while hiding the complexity of instantiation.
- **Key Problems Addressed**:
  - Controls how objects are created (e.g., single instance, factory-based creation).
  - Reduces dependencies on specific classes.
  - Manages object initialization in complex systems.
- **Examples**: Singleton (ensures one instance), Factory Method (delegates object creation), Abstract Factory (creates families of related objects).

### 2. Structural Patterns
- **What it Solves**: Deals with how objects and classes are composed to form larger structures while keeping the system flexible and efficient.
- **Key Problems Addressed**:
  - Simplifies relationships between objects or classes.
  - Adapts interfaces or adds functionality without changing existing code.
  - Organizes code for scalability and maintainability.
- **Examples**: Adapter (makes incompatible interfaces work together), Decorator (adds behavior dynamically), Composite (treats individual and composite objects uniformly).

### 3. Behavioral Patterns
- **What it Solves**: Focuses on communication and interaction between objects, defining how they collaborate to perform tasks.
- **Key Problems Addressed**:
  - Manages algorithms, responsibilities, and communication patterns.
  - Ensures loose coupling between objects.
  - Handles complex control flows or state changes.
- **Examples**: Observer (notifies dependents of state changes), Strategy (swaps algorithms dynamically), Command (encapsulates requests as objects).

### Quick Tip for LLD Prep
- Understand the problem each pattern solves (e.g., "I need one instance" â†’ Singleton).
- Practice applying them to real-world scenarios (e.g., design a parking lot, e-commerce system).
- Be ready to explain trade-offs (e.g., Singleton limits flexibility but ensures one instance).
